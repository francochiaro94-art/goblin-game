<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Goblin in the Lake</title>
    <style>
        :root {
            --forest-dark: #1a3a2e;
            --forest-base: #2d5a3d;
            --forest-moss: #4a7c59;
            --forest-light: #6b9677;
            --bark-dark: #4a3728;
            --bark-base: #6b523a;
            --parchment: #f4e8d4;
            --parchment-dark: #d4c4a8;
            --gold: #daa520;
            --gold-light: #f4d03f;
            --success: #5b9a68;
            --danger: #c44536;
            --water-deep: #2b6a8f;
            --water-light: #4a9ac9;
            --shadow: rgba(0, 0, 0, 0.3);
            --highlight: rgba(255, 255, 255, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Palatino', serif;
            background: linear-gradient(180deg, var(--forest-dark) 0%, var(--forest-base) 40%, var(--forest-moss) 100%);
            overflow: hidden;
            min-height: 100vh;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, transparent 20%, rgba(0,0,0,0.3) 100%);
            pointer-events: none;
        }

        #appShell {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            gap: 24px;
        }

        #gameStage {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .canvas-frame {
            position: relative;
            padding: 16px;
            background: linear-gradient(145deg, var(--bark-dark), var(--bark-base));
            border: 4px solid var(--bark-dark);
            border-radius: 12px;
            box-shadow:
                0 8px 24px var(--shadow),
                inset 0 2px 4px var(--highlight),
                inset 0 -2px 4px rgba(0,0,0,0.2);
        }

        .canvas-frame::before {
            content: '';
            position: absolute;
            inset: 8px;
            border: 2px solid rgba(139, 90, 43, 0.3);
            border-radius: 6px;
            pointer-events: none;
        }

        #gameCanvas {
            display: block;
            background: var(--forest-dark);
            border: 2px solid var(--bark-dark);
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            cursor: crosshair;
        }

        #hudOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            pointer-events: none;
            z-index: 5;
        }

        .hud-plaque {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: linear-gradient(180deg, var(--bark-base), var(--bark-dark));
            border: 3px solid var(--bark-dark);
            border-radius: 0 0 12px 12px;
            box-shadow:
                0 4px 8px var(--shadow),
                inset 0 1px 2px var(--highlight);
            margin: 0 16px;
        }

        #timer {
            font-size: 32px;
            font-weight: bold;
            color: var(--gold-light);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(218, 165, 32, 0.3);
            font-variant-numeric: tabular-nums;
            letter-spacing: 2px;
        }

        #hints {
            font-size: 13px;
            color: var(--parchment);
            opacity: 0.9;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .status-charms {
            position: absolute;
            top: 70px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            pointer-events: none;
            z-index: 6;
        }

        .charm {
            padding: 6px 12px;
            background: linear-gradient(135deg, var(--parchment), var(--parchment-dark));
            border: 2px solid var(--bark-base);
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            color: var(--bark-dark);
            box-shadow: 0 2px 4px var(--shadow);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.3s ease;
        }

        .charm.active {
            opacity: 1;
            transform: translateX(0);
        }

        .charm.helper { border-color: var(--success); color: var(--success); }
        .charm.ai { border-color: var(--gold); color: var(--gold); }
        .charm.speed { border-color: var(--water-deep); color: var(--water-deep); }

        #controlDock {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 320px;
            width: 100%;
        }

        .control-card {
            background: linear-gradient(135deg, var(--parchment), var(--parchment-dark));
            border: 3px solid var(--bark-base);
            border-radius: 12px;
            padding: 14px;
            box-shadow:
                0 4px 12px var(--shadow),
                inset 0 1px 2px rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .control-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, transparent, var(--bark-base), transparent);
        }

        .card-header {
            font-size: 16px;
            font-weight: bold;
            color: var(--bark-dark);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card-header::before {
            content: 'âš™';
            font-size: 18px;
            opacity: 0.6;
        }

        .card-header.tools::before { content: 'ðŸ› '; }
        .card-header.guide::before { content: 'ðŸ“œ'; }

        .btn-toggle {
            width: 100%;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: bold;
            background: linear-gradient(180deg, var(--bark-base), var(--bark-dark));
            color: var(--parchment);
            border: 3px solid var(--bark-dark);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 0 var(--bark-dark), 0 4px 8px var(--shadow);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
        }

        .btn-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 var(--bark-dark), 0 6px 12px var(--shadow);
        }

        .btn-toggle:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 var(--bark-dark), 0 2px 4px var(--shadow);
        }

        .btn-toggle.active {
            background: linear-gradient(180deg, var(--success), #3a7a4a);
            border-color: var(--success);
            box-shadow:
                0 4px 0 #2d5a38,
                0 4px 8px var(--shadow),
                0 0 12px rgba(91, 154, 104, 0.4);
            color: #fff;
        }

        #helperBtn { margin-bottom: 8px; }

        #aiBtn {
            background: linear-gradient(180deg, var(--gold), #c9950d);
            border-color: var(--gold);
            box-shadow: 0 4px 0 #c9950d, 0 4px 8px var(--shadow);
        }

        #aiBtn:hover {
            box-shadow: 0 6px 0 #c9950d, 0 6px 12px var(--shadow);
        }

        #aiBtn:active {
            box-shadow: 0 2px 0 #c9950d, 0 2px 4px var(--shadow);
        }

        #aiBtn.active {
            background: linear-gradient(180deg, var(--gold-light), var(--gold));
            box-shadow:
                0 4px 0 var(--gold),
                0 4px 8px var(--shadow),
                0 0 16px rgba(244, 208, 63, 0.5);
        }

        #speedControl {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
        }

        .speed-inner {
            padding: 16px;
            background: linear-gradient(135deg, var(--parchment), var(--parchment-dark));
            border: 3px solid var(--bark-base);
            border-radius: 12px;
            box-shadow:
                0 4px 12px var(--shadow),
                inset 0 1px 2px rgba(255, 255, 255, 0.3);
        }

        .speed-inner label {
            display: block;
            font-size: 14px;
            font-weight: bold;
            color: var(--bark-dark);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #speedSlider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, var(--bark-dark), var(--bark-base));
            border-radius: 4px;
            outline: none;
            border: 2px solid var(--bark-dark);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #speedSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, var(--gold-light), var(--gold));
            border: 3px solid var(--bark-dark);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px var(--shadow);
            transition: all 0.2s ease;
        }

        #speedSlider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 6px var(--shadow), 0 0 8px rgba(218, 165, 32, 0.4);
        }

        #speedSlider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, var(--gold-light), var(--gold));
            border: 3px solid var(--bark-dark);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px var(--shadow);
            transition: all 0.2s ease;
        }

        #speedSlider::-moz-range-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 6px var(--shadow), 0 0 8px rgba(218, 165, 32, 0.4);
        }

        #speedValue {
            display: inline-block;
            padding: 6px 12px;
            background: linear-gradient(135deg, var(--water-deep), var(--water-light));
            color: white;
            font-weight: bold;
            border-radius: 12px;
            font-size: 14px;
            margin-top: 8px;
            box-shadow: 0 2px 4px var(--shadow);
            border: 2px solid var(--bark-dark);
        }

        #questLog {
            position: relative;
        }

        #questLog.control-card {
            padding: 8px;
        }

        .quest-toggle {
            width: 100%;
            padding: 8px 12px;
            background: linear-gradient(180deg, var(--bark-base), var(--bark-dark));
            color: var(--parchment);
            border: 2px solid var(--bark-dark);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.2s ease;
            box-shadow: 0 3px 0 var(--bark-dark), 0 3px 6px var(--shadow);
        }

        .quest-toggle:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 0 var(--bark-dark), 0 4px 8px var(--shadow);
        }

        .quest-chevron {
            transition: transform 0.3s ease;
        }

        .quest-toggle.open .quest-chevron {
            transform: rotate(180deg);
        }

        #helpPanel {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            background: var(--parchment);
            border: none;
            border-radius: 0 0 6px 6px;
            margin-top: -2px;
            border: 2px solid var(--bark-dark);
            border-top: none;
            box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.1);
        }

        #helpPanel.open {
            max-height: 300px;
            padding: 10px 12px;
        }

        #helpPanel h3 {
            margin-bottom: 8px;
            color: var(--bark-dark);
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #helpPanel p {
            margin-bottom: 5px;
            line-height: 1.4;
            color: var(--bark-dark);
            font-size: 11px;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: linear-gradient(135deg, var(--parchment) 0%, var(--parchment-dark) 100%);
            padding: 40px 50px;
            border-radius: 16px;
            text-align: center;
            color: var(--bark-dark);
            display: none;
            border: 4px solid var(--bark-dark);
            box-shadow:
                0 12px 32px rgba(0, 0, 0, 0.6),
                inset 0 2px 4px rgba(255, 255, 255, 0.3);
            z-index: 100;
            max-width: 90%;
            opacity: 0;
            transition: all 0.3s ease;
        }

        #gameOver.show {
            display: block;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        #gameOver::before {
            content: 'ðŸ”–';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 40px;
            filter: drop-shadow(0 4px 8px var(--shadow));
        }

        #gameOver.win {
            border-color: var(--success);
            animation: victoryPulse 1s ease-in-out;
        }

        #gameOver.lose {
            border-color: var(--danger);
            animation: defeatShake 0.5s ease-in-out;
        }

        @keyframes victoryPulse {
            0%, 100% { box-shadow: 0 12px 32px rgba(0, 0, 0, 0.6); }
            50% { box-shadow: 0 12px 32px rgba(0, 0, 0, 0.6), 0 0 32px rgba(91, 154, 104, 0.6); }
        }

        @keyframes defeatShake {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            25% { transform: translate(-48%, -50%) scale(1); }
            75% { transform: translate(-52%, -50%) scale(1); }
        }

        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        #gameOver.win h1 {
            color: var(--success);
        }

        #gameOver.lose h1 {
            color: var(--danger);
        }

        #gameOver p {
            font-size: 18px;
            margin-bottom: 24px;
            color: var(--bark-dark);
        }

        .stats-row {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        .stat-chip {
            padding: 8px 16px;
            background: linear-gradient(135deg, var(--bark-base), var(--bark-dark));
            color: var(--parchment);
            border-radius: 8px;
            font-size: 13px;
            font-weight: bold;
            border: 2px solid var(--bark-dark);
            box-shadow: 0 2px 4px var(--shadow);
        }

        #restartBtn {
            padding: 14px 32px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(180deg, var(--bark-base), var(--bark-dark));
            color: var(--parchment);
            border: 3px solid var(--bark-dark);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 0 var(--bark-dark), 0 4px 8px var(--shadow);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #restartBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 var(--bark-dark), 0 6px 12px var(--shadow);
            background: linear-gradient(180deg, #7d6342, var(--bark-dark));
        }

        #restartBtn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 var(--bark-dark), 0 2px 4px var(--shadow);
        }

        @media (max-width: 900px) {
            #appShell {
                flex-direction: column;
                padding: 12px;
            }

            #controlDock {
                max-width: 100%;
                width: 100%;
            }

            .canvas-frame {
                padding: 12px;
            }

            #timer {
                font-size: 24px;
            }

            #hints {
                font-size: 11px;
            }

            .hud-plaque {
                padding: 8px 12px;
                margin: 0 8px;
            }

            .status-charms {
                top: 60px;
                right: 12px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        #ui {
            display: none;
        }

        .victory-particles {
            position: absolute;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 99;
        }

        .leaf {
            position: absolute;
            width: 8px;
            height: 12px;
            background: linear-gradient(135deg, var(--success), var(--forest-moss));
            border-radius: 50% 0;
            opacity: 0;
            animation: leafFall 3s ease-in-out infinite;
        }

        @keyframes leafFall {
            0% {
                transform: translateY(-20px) rotate(0deg);
                opacity: 0;
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% {
                transform: translateY(120vh) rotate(720deg);
                opacity: 0;
            }
        }

        .leaf:nth-child(1) { left: 10%; animation-delay: 0s; }
        .leaf:nth-child(2) { left: 20%; animation-delay: 0.3s; }
        .leaf:nth-child(3) { left: 30%; animation-delay: 0.6s; }
        .leaf:nth-child(4) { left: 40%; animation-delay: 0.9s; }
        .leaf:nth-child(5) { left: 50%; animation-delay: 1.2s; }
        .leaf:nth-child(6) { left: 60%; animation-delay: 1.5s; }
        .leaf:nth-child(7) { left: 70%; animation-delay: 1.8s; }
        .leaf:nth-child(8) { left: 80%; animation-delay: 2.1s; }
        .leaf:nth-child(9) { left: 90%; animation-delay: 2.4s; }

        #distanceChart {
            width: 100%;
            height: 200px;
            background: linear-gradient(135deg, var(--parchment), var(--parchment-dark));
            border: 2px solid var(--bark-dark);
            border-radius: 8px;
            display: block;
        }

        .chart-card {
            max-height: 280px;
        }

        .chart-card .card-header::before {
            content: 'ðŸ“Š';
        }
    </style>
</head>
<body>
    <div id="appShell">
        <div id="gameStage">
            <div class="canvas-frame">
                <canvas id="gameCanvas"></canvas>
                <div id="hudOverlay">
                    <div class="hud-plaque">
                        <div id="timer">0.0s</div>
                        <div id="hints">Arrow keys or mouse â€¢ R restart â€¢ H helper</div>
                    </div>
                </div>
                <div class="status-charms">
                    <div class="charm helper" id="helperCharm">Helper</div>
                    <div class="charm ai" id="aiCharm">AI Control</div>
                    <div class="charm speed" id="speedCharm">4.0Ã—</div>
                </div>
            </div>

            <div id="gameOver">
                <h1 id="resultText">You Win!</h1>
                <p id="resultDetail">You escaped the goblin!</p>
                <div class="stats-row" id="statsRow"></div>
                <button id="restartBtn">Restart (R)</button>
            </div>
        </div>

        <div id="controlDock">
            <div class="control-card">
                <div class="card-header tools">Tools</div>
                <button id="helperBtn" class="btn-toggle">Helper: Off</button>
                <button id="aiBtn" class="btn-toggle">AI Control: Off</button>
            </div>

            <div class="control-card" id="speedControl">
                <div class="speed-inner">
                    <label for="speedSlider">Goblin Speed</label>
                    <input type="range" id="speedSlider" min="0.5" max="4.3" step="0.1" value="4.0">
                    <span id="speedValue">4.0x faster</span>
                </div>
            </div>

            <div class="control-card" id="radiusControl">
                <div class="speed-inner">
                    <label for="radiusSlider">Lake Radius</label>
                    <input type="range" id="radiusSlider" min="80" max="250" step="10" value="150">
                    <span id="radiusValue">150m</span>
                </div>
            </div>

            <div class="control-card" id="questLog">
                <button class="quest-toggle" id="questToggle">
                    <span>Quest Log</span>
                    <span class="quest-chevron">â–¼</span>
                </button>
                <div id="helpPanel">
                    <h3>ðŸŽ¯ How to Win</h3>
                    <p>â€¢ Row with arrow keys or mouse/trackpad</p>
                    <p>â€¢ Reach the shore before the goblin catches you</p>
                    <p>â€¢ Adjust goblin speed with the slider (0.5x-4.3x)</p>
                    <p>â€¢ Press H to toggle helper guide</p>
                    <p>â€¢ Enable AI Control to watch the optimal strategy</p>
                </div>
            </div>

            <div class="control-card chart-card">
                <div class="card-header">Distance Tracker</div>
                <canvas id="distanceChart"></canvas>
            </div>
        </div>
    </div>

    <div id="ui" style="display: none;">
        <div id="timer">0.0s</div>
        <div id="hints">Arrow keys or mouse to row â€¢ R to restart â€¢ H for helper</div>
    </div>

    <script>
        // ===== CANVAS SETUP =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        function resizeCanvas() {
            const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.85, 800);
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            ctx.scale(dpr, dpr);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ===== DISTANCE CHART SETUP =====
        const chartCanvas = document.getElementById('distanceChart');
        const chartCtx = chartCanvas.getContext('2d');

        function resizeChartCanvas() {
            const rect = chartCanvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            chartCanvas.width = rect.width * dpr;
            chartCanvas.height = rect.height * dpr;
            chartCanvas.style.width = rect.width + 'px';
            chartCanvas.style.height = rect.height + 'px';
        }
        resizeChartCanvas();
        window.addEventListener('resize', resizeChartCanvas);

        let distanceData = [];
        let lastDataUpdate = 0;
        const DATA_UPDATE_INTERVAL = 0.1; // 100ms

        // ===== CONSTANTS =====
        let LAKE_RADIUS = 150;
        const PLAYER_RADIUS = 8;
        const GOBLIN_RADIUS = 10;
        const PLAYER_MAX_SPEED = 120;
        const PLAYER_ACCEL = 400;
        const PLAYER_DRAG = 0.98;
        const CATCH_ARC_THRESHOLD = 22;
        const PREDICTION_HORIZON = 0.35;
        const MAX_DT = 0.05;

        let speedRatio = 4.0;

        function getGoblinSpeed() {
            return PLAYER_MAX_SPEED * speedRatio;
        }

        function getCriticalRadius() {
            return LAKE_RADIUS / speedRatio;
        }

        function getSafeRadius() {
            return getCriticalRadius() * 0.95;
        }

        // ===== HELPER FUNCTIONS =====
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function wrapAngle(angle) {
            while (angle > Math.PI) angle -= 2 * Math.PI;
            while (angle < -Math.PI) angle += 2 * Math.PI;
            return angle;
        }

        function shortestAngularDiff(from, to) {
            let diff = to - from;
            return wrapAngle(diff);
        }

        function length(x, y) {
            return Math.sqrt(x * x + y * y);
        }

        function normalize(x, y) {
            const len = length(x, y);
            if (len === 0) return { x: 0, y: 0 };
            return { x: x / len, y: y / len };
        }

        // ===== GAME STATE =====
        let gameState = 'playing';
        let timer = 0;
        let lastTime = performance.now();
        let helperEnabled = false;
        let aiControlEnabled = false;
        let aiState = 'spin';
        let aiDashAngle = 0;
        let aiAlignedTime = 0;
        let aiLastThetaB = 0;

        const player = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            angle: 0,
            bobPhase: 0
        };

        const goblin = {
            theta: Math.random() * Math.PI * 2,
            bobPhase: 0
        };

        const keys = {
            up: false,
            down: false,
            left: false,
            right: false,
            mouseActive: false,
            mouseX: 0,
            mouseY: 0
        };

        // ===== INPUT HANDLING =====
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') keys.up = true;
            if (e.key === 'ArrowDown') keys.down = true;
            if (e.key === 'ArrowLeft') keys.left = true;
            if (e.key === 'ArrowRight') keys.right = true;
            if (e.key === 'r' || e.key === 'R') restart();
            if (e.key === 'h' || e.key === 'H') toggleHelper();
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp') keys.up = false;
            if (e.key === 'ArrowDown') keys.down = false;
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            keys.mouseX = (e.clientX - rect.left) * (canvas.width / rect.width) / dpr;
            keys.mouseY = (e.clientY - rect.top) * (canvas.height / rect.height) / dpr;
            keys.mouseActive = true;
        });

        canvas.addEventListener('mouseleave', () => {
            keys.mouseActive = false;
        });

        document.addEventListener('keydown', (e) => {
            if (e.key.startsWith('Arrow')) {
                keys.mouseActive = false;
            }
        });

        document.getElementById('restartBtn').addEventListener('click', restart);
        document.getElementById('helperBtn').addEventListener('click', toggleHelper);
        document.getElementById('aiBtn').addEventListener('click', toggleAI);

        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');

        speedSlider.addEventListener('input', (e) => {
            speedRatio = parseFloat(e.target.value);
            speedValue.textContent = speedRatio.toFixed(1) + 'x faster';
            updateSpeedCharm();
        });

        const radiusSlider = document.getElementById('radiusSlider');
        const radiusValue = document.getElementById('radiusValue');

        radiusSlider.addEventListener('input', (e) => {
            LAKE_RADIUS = parseFloat(e.target.value);
            radiusValue.textContent = LAKE_RADIUS.toFixed(0) + 'm';
        });

        document.getElementById('questToggle').addEventListener('click', () => {
            const panel = document.getElementById('helpPanel');
            const toggle = document.getElementById('questToggle');
            panel.classList.toggle('open');
            toggle.classList.toggle('open');
        });

        function toggleHelper() {
            helperEnabled = !helperEnabled;
            const helperBtn = document.getElementById('helperBtn');
            if (helperEnabled) {
                helperBtn.textContent = 'Helper: On';
                helperBtn.classList.add('active');
            } else {
                helperBtn.textContent = 'Helper: Off';
                helperBtn.classList.remove('active');
            }
            updateHelperCharm();
        }

        function toggleAI() {
            aiControlEnabled = !aiControlEnabled;
            const aiBtn = document.getElementById('aiBtn');
            if (aiControlEnabled) {
                aiBtn.textContent = 'AI Control: On';
                aiBtn.classList.add('active');
            } else {
                aiBtn.textContent = 'AI Control: Off';
                aiBtn.classList.remove('active');
            }
            updateAICharm();
        }

        function updateHelperCharm() {
            const charm = document.getElementById('helperCharm');
            if (helperEnabled) {
                charm.classList.add('active');
            } else {
                charm.classList.remove('active');
            }
        }

        function updateAICharm() {
            const charm = document.getElementById('aiCharm');
            if (aiControlEnabled) {
                charm.classList.add('active');
            } else {
                charm.classList.remove('active');
            }
        }

        function updateSpeedCharm() {
            const charm = document.getElementById('speedCharm');
            charm.textContent = speedRatio.toFixed(1) + 'Ã—';
            charm.classList.add('active');
        }

        function restart() {
            gameState = 'playing';
            timer = 0;
            player.x = 0;
            player.y = 0;
            player.vx = 0;
            player.vy = 0;
            player.angle = 0;
            player.bobPhase = 0;
            goblin.theta = Math.random() * Math.PI * 2;
            goblin.bobPhase = 0;
            keys.up = false;
            keys.down = false;
            keys.left = false;
            keys.right = false;
            aiState = 'spin';
            aiDashAngle = 0;
            aiAlignedTime = 0;
            aiLastThetaB = 0;
            distanceData = [];
            lastDataUpdate = 0;
            document.getElementById('gameOver').classList.remove('show');
            const particles = document.querySelector('.victory-particles');
            if (particles) particles.remove();
            lastTime = performance.now();
        }

        // ===== UPDATE LOGIC =====
        function update(dt) {
            if (gameState !== 'playing') return;

            timer += dt;

            player.bobPhase += dt * 3;
            goblin.bobPhase += dt * 5;

            // Update distance data every 100ms
            lastDataUpdate += dt;
            if (lastDataUpdate >= DATA_UPDATE_INTERVAL) {
                const goblinX = Math.cos(goblin.theta) * LAKE_RADIUS;
                const goblinY = Math.sin(goblin.theta) * LAKE_RADIUS;
                const distance = Math.sqrt(
                    Math.pow(player.x - goblinX, 2) + Math.pow(player.y - goblinY, 2)
                );
                distanceData.push({ time: timer, distance: distance });
                lastDataUpdate = 0;
            }

            let dx = 0, dy = 0;

            if (aiControlEnabled) {
                const rb = length(player.x, player.y);
                const thetaG = goblin.theta;
                const thetaOpp = wrapAngle(thetaG + Math.PI);
                const safeRadius = getSafeRadius();
                const criticalRadius = getCriticalRadius();
                const RING_TOL = 16;
                const ALIGN_TOL = 0.15;
                const ALIGN_HOLD = 0.35;
                const SPIN_RADIUS = Math.max(14, Math.min(criticalRadius * 0.75, safeRadius * 0.75));
                const CENTER_EPS = 6;

                let thetaB;
                if (rb > CENTER_EPS) {
                    thetaB = Math.atan2(player.y, player.x);
                    aiLastThetaB = thetaB;
                } else if (length(player.vx, player.vy) > 5) {
                    thetaB = Math.atan2(player.vy, player.vx);
                    aiLastThetaB = thetaB;
                } else {
                    thetaB = aiLastThetaB;
                }

                const diffToOpp = shortestAngularDiff(thetaB, thetaOpp);
                const absDiffToOpp = Math.abs(diffToOpp);
                const orbitDir = diffToOpp > 0 ? 1 : -1;
                const tangentAngle = thetaB + orbitDir * Math.PI / 2;

                function radialCorrection(targetR, gain) {
                    const rErr = rb - targetR;
                    if (rb < 1e-6) return { rx: 0, ry: 0 };
                    const ux = player.x / rb;
                    const uy = player.y / rb;
                    return { rx: -ux * rErr * gain, ry: -uy * rErr * gain };
                }

                if (aiState !== 'dash') {
                    if (absDiffToOpp <= ALIGN_TOL && Math.abs(rb - safeRadius) <= RING_TOL) {
                        aiAlignedTime += dt;
                    } else {
                        aiAlignedTime = 0;
                    }
                }

                if (aiState === 'dash') {
                    dx = Math.cos(aiDashAngle);
                    dy = Math.sin(aiDashAngle);
                } else if (aiState === 'spin') {
                    let baseAngle = (rb > CENTER_EPS) ? thetaB : thetaG;
                    let spinTangent = baseAngle + Math.PI / 2;
                    if (rb > CENTER_EPS && diffToOpp < 0) spinTangent = baseAngle - Math.PI / 2;

                    const out = radialCorrection(SPIN_RADIUS, 0.06);
                    dx = Math.cos(spinTangent) + out.rx;
                    dy = Math.sin(spinTangent) + out.ry;

                    if (rb >= SPIN_RADIUS - 4) {
                        aiState = 'orbit';
                    }
                } else {
                    if (aiAlignedTime >= ALIGN_HOLD) {
                        aiState = 'dash';
                        aiDashAngle = thetaOpp;
                        dx = Math.cos(aiDashAngle);
                        dy = Math.sin(aiDashAngle);
                    } else {
                        const rad = radialCorrection(safeRadius, 0.05);
                        dx = Math.cos(tangentAngle) + rad.rx;
                        dy = Math.sin(tangentAngle) + rad.ry;

                        if (rb > safeRadius + 2 * RING_TOL || rb < SPIN_RADIUS * 0.7) {
                            aiState = 'spin';
                        }
                    }
                }
            } else {
                if (keys.up) dy -= 1;
                if (keys.down) dy += 1;
                if (keys.left) dx -= 1;
                if (keys.right) dx += 1;

                if (keys.mouseActive) {
                    const centerX = canvas.width / (2 * dpr);
                    const centerY = canvas.height / (2 * dpr);
                    const targetX = keys.mouseX - centerX;
                    const targetY = keys.mouseY - centerY;
                    const distToTarget = length(targetX - player.x, targetY - player.y);

                    if (distToTarget > 5) {
                        const norm = normalize(targetX - player.x, targetY - player.y);
                        dx = norm.x;
                        dy = norm.y;
                    }
                }
            }

            const dirLen = length(dx, dy);
            if (dirLen > 0) {
                dx = (dx / dirLen) * PLAYER_MAX_SPEED * dt;
                dy = (dy / dirLen) * PLAYER_MAX_SPEED * dt;

                player.vx = dx / dt;
                player.vy = dy / dt;

                player.x += dx;
                player.y += dy;

                player.angle = Math.atan2(dy, dx);
            } else {
                player.vx = 0;
                player.vy = 0;
            }

            const playerAngle = Math.atan2(player.y, player.x);
            const futureX = player.x + player.vx * PREDICTION_HORIZON;
            const futureY = player.y + player.vy * PREDICTION_HORIZON;
            const predictedAngle = Math.atan2(futureY, futureX);
            const targetAngle = wrapAngle(lerp(playerAngle, predictedAngle, 0.6));

            const angleDiff = shortestAngularDiff(goblin.theta, targetAngle);
            const goblinAngularSpeed = getGoblinSpeed() / LAKE_RADIUS;
            const maxMove = goblinAngularSpeed * dt;

            if (Math.abs(angleDiff) < maxMove) {
                goblin.theta = targetAngle;
            } else {
                goblin.theta += Math.sign(angleDiff) * maxMove;
            }
            goblin.theta = wrapAngle(goblin.theta);

            const distFromCenter = length(player.x, player.y);
            if (distFromCenter >= LAKE_RADIUS - PLAYER_RADIUS) {
                const landingAngle = Math.atan2(player.y, player.x);
                const arcDist = LAKE_RADIUS * Math.abs(shortestAngularDiff(goblin.theta, landingAngle));

                if (arcDist <= CATCH_ARC_THRESHOLD) {
                    gameState = 'lost';
                    showGameOver(false);
                } else {
                    gameState = 'won';
                    showGameOver(true);
                }

                player.vx = 0;
                player.vy = 0;
            }
        }

        // ===== RENDERING =====
        function draw() {
            const centerX = canvas.width / (2 * dpr);
            const centerY = canvas.height / (2 * dpr);

            ctx.fillStyle = '#0f2a1a';
            ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);

            ctx.save();
            ctx.translate(centerX, centerY);

            drawScenery();
            drawLake();

            ctx.strokeStyle = '#8d6e63';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, LAKE_RADIUS, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = '#d7ccc8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, LAKE_RADIUS + 6, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = 'rgba(139, 90, 43, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, LAKE_RADIUS + 3, 0, Math.PI * 2);
            ctx.stroke();

            drawGoblin();
            drawBoat();

            if (helperEnabled && gameState === 'playing') {
                drawHelperPath();
            }

            ctx.restore();

            document.getElementById('timer').textContent = timer.toFixed(1) + 's';
        }

        function drawLake() {
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, LAKE_RADIUS);
            gradient.addColorStop(0, '#5fa3c9');
            gradient.addColorStop(0.4, '#4a9ac9');
            gradient.addColorStop(0.8, '#3a8ab9');
            gradient.addColorStop(1, '#2b7aa9');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, LAKE_RADIUS, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
                const offset = (timer * 15 + i * 25) % 100;
                ctx.beginPath();
                ctx.arc(0, 0, LAKE_RADIUS * 0.25 + offset, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.save();
            ctx.globalAlpha = 0.15;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const dist = LAKE_RADIUS * 0.85 + Math.sin(timer * 2 + i) * 5;
                const x = Math.cos(angle) * dist;
                const y = Math.sin(angle) * dist;
                ctx.fillStyle = '#2d7d52';
                ctx.beginPath();
                ctx.ellipse(x, y, 8, 6, angle, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawScenery() {
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const randomOffset = ((i * 7919) % 100) / 5;
                const dist = LAKE_RADIUS + 30 + randomOffset;
                const x = Math.cos(angle) * dist;
                const y = Math.sin(angle) * dist;
                const scale = 0.8 + ((i * 31) % 40) / 100;

                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#1a3a2e';
                ctx.beginPath();
                ctx.ellipse(x, y + 8, 8 * scale, 3 * scale, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                ctx.fillStyle = '#5d4037';
                ctx.fillRect(x - 3 * scale, y - 8 * scale, 6 * scale, 16 * scale);

                const gradient = ctx.createRadialGradient(x, y - 12 * scale, 0, x, y - 12 * scale, 10 * scale);
                gradient.addColorStop(0, '#4a7c59');
                gradient.addColorStop(0.7, '#3a6c49');
                gradient.addColorStop(1, '#2a5c39');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y - 12 * scale, 10 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x - 5 * scale, y - 8 * scale, 8 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x + 5 * scale, y - 8 * scale, 8 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawBoat() {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);

            const bobOffset = Math.sin(player.bobPhase) * 1.5;
            ctx.translate(0, bobOffset);

            ctx.save();
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = '#1a3a2e';
            ctx.beginPath();
            ctx.ellipse(2, 8, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            ctx.fillStyle = '#8d6e63';
            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(0, 0, 14, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#d7ccc8';
            ctx.beginPath();
            ctx.ellipse(0, 0, 10, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ffeb3b';
            ctx.strokeStyle = '#f57c00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        }

        function drawGoblin() {
            const x = Math.cos(goblin.theta) * LAKE_RADIUS;
            const y = Math.sin(goblin.theta) * LAKE_RADIUS;

            ctx.save();
            ctx.translate(x, y);

            const angleToPlayer = Math.atan2(player.y - y, player.x - x);
            ctx.rotate(angleToPlayer);

            const bobOffset = Math.sin(goblin.bobPhase) * 2;
            ctx.translate(0, bobOffset);

            ctx.save();
            ctx.globalAlpha = 0.25;
            ctx.fillStyle = '#1a3a2e';
            ctx.beginPath();
            ctx.ellipse(2, GOBLIN_RADIUS + 4, GOBLIN_RADIUS + 2, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            const gradient = ctx.createRadialGradient(0, -2, 0, 0, 0, GOBLIN_RADIUS);
            gradient.addColorStop(0, '#5fcc6f');
            gradient.addColorStop(0.7, '#4caf50');
            gradient.addColorStop(1, '#3a8f40');
            ctx.fillStyle = gradient;
            ctx.strokeStyle = '#2e7d32';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, GOBLIN_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#ff5722';
            ctx.beginPath();
            ctx.arc(-3, -2, 2, 0, Math.PI * 2);
            ctx.arc(3, -2, 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#2e7d32';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(0, 1, 4, 0, Math.PI);
            ctx.stroke();

            ctx.fillStyle = '#3a8f40';
            ctx.beginPath();
            ctx.moveTo(-5, -GOBLIN_RADIUS + 2);
            ctx.lineTo(-8, -GOBLIN_RADIUS - 3);
            ctx.lineTo(-4, -GOBLIN_RADIUS);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(5, -GOBLIN_RADIUS + 2);
            ctx.lineTo(8, -GOBLIN_RADIUS - 3);
            ctx.lineTo(4, -GOBLIN_RADIUS);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawHelperPath() {
            const RING_TOL = 10;
            const ALIGN_TOL = 0.20;
            const PREDICTION_TIME = 0.25;

            const safeRadius = getSafeRadius();
            const rb = length(player.x, player.y);
            const thetaB = Math.atan2(player.y, player.x);
            const thetaG = goblin.theta;

            const predX = player.x + player.vx * PREDICTION_TIME;
            const predY = player.y + player.vy * PREDICTION_TIME;
            const predictedAngle = Math.atan2(predY, predX);

            const thetaOpp = wrapAngle(thetaG + Math.PI);
            const err = Math.abs(shortestAngularDiff(thetaB, thetaOpp));

            ctx.save();
            ctx.beginPath();
            ctx.arc(0, 0, LAKE_RADIUS, 0, Math.PI * 2);
            ctx.clip();

            let helperText = "";

            if (rb > safeRadius + RING_TOL) {
                helperText = "NEXT: Get inside the safe ring";

                ctx.strokeStyle = 'rgba(218, 165, 32, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 8]);
                ctx.beginPath();
                ctx.arc(0, 0, safeRadius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.strokeStyle = 'rgba(218, 165, 32, 0.8)';
                ctx.lineWidth = 3;
                const norm = normalize(player.x, player.y);
                const targetX = norm.x * safeRadius;
                const targetY = norm.y * safeRadius;
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(targetX, targetY);
                ctx.stroke();

                ctx.fillStyle = 'rgba(218, 165, 32, 0.9)';
                ctx.beginPath();
                ctx.arc(targetX, targetY, 5, 0, Math.PI * 2);
                ctx.fill();
            } else if (rb < safeRadius - RING_TOL) {
                helperText = "NEXT: Move out to the ring, then circle";

                ctx.strokeStyle = 'rgba(218, 165, 32, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 8]);
                ctx.beginPath();
                ctx.arc(0, 0, safeRadius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.strokeStyle = 'rgba(218, 165, 32, 0.8)';
                ctx.lineWidth = 3;
                const angle = length(player.vx, player.vy) > 5 ? Math.atan2(player.vy, player.vx) : thetaB;
                const targetX = Math.cos(angle) * safeRadius;
                const targetY = Math.sin(angle) * safeRadius;
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(targetX, targetY);
                ctx.stroke();

                ctx.fillStyle = 'rgba(218, 165, 32, 0.9)';
                ctx.beginPath();
                ctx.arc(targetX, targetY, 5, 0, Math.PI * 2);
                ctx.fill();
            } else if (err <= ALIGN_TOL) {
                helperText = "NEXT: Sprint straight out to the shore NOW!";

                ctx.strokeStyle = 'rgba(218, 165, 32, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([6, 8]);
                ctx.beginPath();
                ctx.arc(0, 0, safeRadius, 0, Math.PI * 2);
                ctx.stroke();

                const escapeStartX = Math.cos(thetaOpp) * safeRadius;
                const escapeStartY = Math.sin(thetaOpp) * safeRadius;
                const escapeEndX = Math.cos(thetaOpp) * LAKE_RADIUS;
                const escapeEndY = Math.sin(thetaOpp) * LAKE_RADIUS;

                ctx.strokeStyle = 'rgba(91, 154, 104, 0.9)';
                ctx.lineWidth = 4;
                ctx.setLineDash([8, 6]);
                ctx.beginPath();
                ctx.moveTo(escapeStartX, escapeStartY);
                ctx.lineTo(escapeEndX, escapeEndY);
                ctx.stroke();

                ctx.fillStyle = 'rgba(91, 154, 104, 0.9)';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('EXIT', escapeEndX, escapeEndY);

                const pulse = Math.sin(performance.now() / 200) * 0.3 + 0.7;
                ctx.fillStyle = `rgba(91, 154, 104, ${pulse})`;
                ctx.beginPath();
                ctx.arc(escapeEndX, escapeEndY, 8, 0, Math.PI * 2);
                ctx.fill();
            } else {
                helperText = "NEXT: Circle on the ring until you're opposite the goblin";

                ctx.strokeStyle = 'rgba(218, 165, 32, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 8]);
                ctx.beginPath();
                ctx.arc(0, 0, safeRadius, 0, Math.PI * 2);
                ctx.stroke();

                const angleDiff = shortestAngularDiff(predictedAngle, thetaOpp);
                const arcDirection = angleDiff > 0;

                ctx.strokeStyle = 'rgba(218, 165, 32, 0.9)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, safeRadius, predictedAngle, thetaOpp, !arcDirection);
                ctx.stroke();

                const numArrows = 3;
                for (let i = 1; i <= numArrows; i++) {
                    const t = i / (numArrows + 1);
                    const arcAngle = predictedAngle + angleDiff * t;
                    const arrowX = Math.cos(arcAngle) * safeRadius;
                    const arrowY = Math.sin(arcAngle) * safeRadius;

                    const arrowSize = 8;
                    const tangentAngle = arcAngle + (arcDirection ? Math.PI / 2 : -Math.PI / 2);

                    ctx.fillStyle = 'rgba(218, 165, 32, 0.9)';
                    ctx.beginPath();
                    ctx.moveTo(
                        arrowX + Math.cos(tangentAngle) * arrowSize,
                        arrowY + Math.sin(tangentAngle) * arrowSize
                    );
                    ctx.lineTo(
                        arrowX + Math.cos(tangentAngle + 2.5) * arrowSize * 0.5,
                        arrowY + Math.sin(tangentAngle + 2.5) * arrowSize * 0.5
                    );
                    ctx.lineTo(
                        arrowX + Math.cos(tangentAngle - 2.5) * arrowSize * 0.5,
                        arrowY + Math.sin(tangentAngle - 2.5) * arrowSize * 0.5
                    );
                    ctx.closePath();
                    ctx.fill();
                }

                const targetX = Math.cos(thetaOpp) * safeRadius;
                const targetY = Math.sin(thetaOpp) * safeRadius;
                const pulse = Math.sin(performance.now() / 200) * 0.3 + 0.7;

                ctx.fillStyle = `rgba(218, 165, 32, ${pulse})`;
                ctx.beginPath();
                ctx.arc(targetX, targetY, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = 'rgba(218, 165, 32, 0.7)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(targetX, targetY, 10, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.setLineDash([]);
            ctx.restore();

            if (helperText) {
                ctx.save();
                ctx.fillStyle = 'rgba(74, 58, 40, 0.9)';
                ctx.fillRect(-150, -LAKE_RADIUS - 50, 300, 40);

                ctx.fillStyle = '#f4d03f';
                ctx.font = 'bold 16px Georgia';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 4;
                ctx.fillText(helperText, 0, -LAKE_RADIUS - 30);
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        function showGameOver(won) {
            const gameOverDiv = document.getElementById('gameOver');
            const resultText = document.getElementById('resultText');
            const resultDetail = document.getElementById('resultDetail');

            gameOverDiv.classList.remove('win', 'lose');

            if (won) {
                gameOverDiv.classList.add('win');
                resultText.textContent = 'Victory!';
                resultDetail.textContent = `You escaped in ${timer.toFixed(1)} seconds!`;
                createVictoryParticles();
            } else {
                gameOverDiv.classList.add('lose');
                resultText.textContent = 'Caught!';
                resultDetail.textContent = `The goblin caught you after ${timer.toFixed(1)} seconds!`;
            }

            const statsRow = document.getElementById('statsRow');
            statsRow.innerHTML = `
                <div class="stat-chip">â± ${timer.toFixed(1)}s</div>
                <div class="stat-chip">âš¡ ${speedRatio.toFixed(1)}Ã— Speed</div>
                <div class="stat-chip">${aiControlEnabled ? 'ðŸ¤– AI' : 'ðŸ‘¤ Manual'}</div>
            `;

            gameOverDiv.classList.add('show');
        }

        function createVictoryParticles() {
            const particles = document.createElement('div');
            particles.className = 'victory-particles';
            for (let i = 0; i < 9; i++) {
                const leaf = document.createElement('div');
                leaf.className = 'leaf';
                particles.appendChild(leaf);
            }
            document.getElementById('gameStage').appendChild(particles);
        }

        function drawDistanceChart() {
            const dpr = window.devicePixelRatio || 1;
            const rect = chartCanvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            const padding = { top: 20, right: 20, bottom: 30, left: 50 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;

            // Clear canvas
            chartCtx.save();
            chartCtx.scale(dpr, dpr);
            chartCtx.fillStyle = '#f4e8d4';
            chartCtx.fillRect(0, 0, width, height);

            if (distanceData.length < 2) {
                // Show placeholder text
                chartCtx.fillStyle = '#6b523a';
                chartCtx.font = '14px Georgia';
                chartCtx.textAlign = 'center';
                chartCtx.textBaseline = 'middle';
                chartCtx.fillText('Tracking distance...', width / 2, height / 2);
                chartCtx.restore();
                return;
            }

            // Calculate scales
            const maxTime = Math.max(...distanceData.map(d => d.time));
            const maxDistance = Math.max(...distanceData.map(d => d.distance));
            const minDistance = Math.min(...distanceData.map(d => d.distance));
            const distanceRange = maxDistance - minDistance;
            const distancePadding = distanceRange * 0.1;
            const yMin = Math.max(0, minDistance - distancePadding);
            const yMax = maxDistance + distancePadding;

            // Draw axes
            chartCtx.strokeStyle = '#6b523a';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            chartCtx.moveTo(padding.left, padding.top);
            chartCtx.lineTo(padding.left, height - padding.bottom);
            chartCtx.lineTo(width - padding.right, height - padding.bottom);
            chartCtx.stroke();

            // Draw grid lines (horizontal)
            chartCtx.strokeStyle = 'rgba(107, 82, 58, 0.2)';
            chartCtx.lineWidth = 1;
            const numYGridLines = 4;
            for (let i = 0; i <= numYGridLines; i++) {
                const y = padding.top + (plotHeight / numYGridLines) * i;
                chartCtx.beginPath();
                chartCtx.moveTo(padding.left, y);
                chartCtx.lineTo(width - padding.right, y);
                chartCtx.stroke();

                // Y-axis labels
                const distValue = yMax - (yMax - yMin) * (i / numYGridLines);
                chartCtx.fillStyle = '#6b523a';
                chartCtx.font = '11px Georgia';
                chartCtx.textAlign = 'right';
                chartCtx.textBaseline = 'middle';
                chartCtx.fillText(distValue.toFixed(0) + 'm', padding.left - 5, y);
            }

            // Draw grid lines (vertical)
            const numXGridLines = Math.min(5, Math.floor(maxTime));
            for (let i = 0; i <= numXGridLines; i++) {
                const x = padding.left + (plotWidth / numXGridLines) * i;
                chartCtx.strokeStyle = 'rgba(107, 82, 58, 0.2)';
                chartCtx.lineWidth = 1;
                chartCtx.beginPath();
                chartCtx.moveTo(x, padding.top);
                chartCtx.lineTo(x, height - padding.bottom);
                chartCtx.stroke();

                // X-axis labels
                const timeValue = (maxTime / numXGridLines) * i;
                chartCtx.fillStyle = '#6b523a';
                chartCtx.font = '11px Georgia';
                chartCtx.textAlign = 'center';
                chartCtx.textBaseline = 'top';
                chartCtx.fillText(timeValue.toFixed(1) + 's', x, height - padding.bottom + 5);
            }

            // Draw data line
            chartCtx.strokeStyle = '#2b6a8f';
            chartCtx.lineWidth = 2.5;
            chartCtx.beginPath();

            for (let i = 0; i < distanceData.length; i++) {
                const point = distanceData[i];
                const x = padding.left + (point.time / maxTime) * plotWidth;
                const y = height - padding.bottom - ((point.distance - yMin) / (yMax - yMin)) * plotHeight;

                if (i === 0) {
                    chartCtx.moveTo(x, y);
                } else {
                    chartCtx.lineTo(x, y);
                }
            }
            chartCtx.stroke();

            // Draw data points
            chartCtx.fillStyle = '#4a9ac9';
            for (let i = 0; i < distanceData.length; i++) {
                const point = distanceData[i];
                const x = padding.left + (point.time / maxTime) * plotWidth;
                const y = height - padding.bottom - ((point.distance - yMin) / (yMax - yMin)) * plotHeight;

                chartCtx.beginPath();
                chartCtx.arc(x, y, 2, 0, Math.PI * 2);
                chartCtx.fill();
            }

            // Draw axis labels
            chartCtx.fillStyle = '#6b523a';
            chartCtx.font = 'bold 12px Georgia';
            chartCtx.textAlign = 'center';
            chartCtx.textBaseline = 'bottom';
            chartCtx.fillText('Time (seconds)', width / 2, height - 5);

            chartCtx.save();
            chartCtx.translate(12, height / 2);
            chartCtx.rotate(-Math.PI / 2);
            chartCtx.textAlign = 'center';
            chartCtx.textBaseline = 'bottom';
            chartCtx.fillText('Distance (meters)', 0, 0);
            chartCtx.restore();

            chartCtx.restore();
        }

        // ===== GAME LOOP =====
        function gameLoop(currentTime) {
            let dt = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            dt = clamp(dt, 0, MAX_DT);

            update(dt);
            draw();
            drawDistanceChart();

            requestAnimationFrame(gameLoop);
        }

        restart();
        gameLoop(performance.now());
        updateSpeedCharm();
    </script>
</body>
</html>
